# Wartime Ciphers

## About this project

I have succumbed to quarantine boredom and have created two Python 3 implementations of German WW2 ciphers. Both are written in Python 3.8.3 but should be compatible with Python 3.7 or before.



## Enigma

### How Enigma Works

The Enigma machine works by taking an input key, running it through a complicated wiring that jumbles the character input into a completely different one.

When a key is pressed, the electrical signal is sent into the plugboard. This essentially ties two letters together, such that if one is pressed it acts as if the other is. From the plugboard, this is sent to the rotors. Each rotor maps each character to a different character, seemingly randomly. Each time a key is pressed the first rotor turns, when the first rotor makes a full rotation the second rotor will turn, and when the second makes a full rotation the third rotor will turn. The signal passes through three of these rotors, before hitting the reflector. This is similar to the rotors in that it maps each character to a different character, but it differs in two aspects:

  - It does not rotate.
  - It is symmetrical (i.e. if A becomes H, H would become A).
  
From the reflector, the signal is sent back through the rotors in reverse order, and then from there it gets sent back through the plugboard, and finally it will light up the relevant lamp to character that is encoded.



### How to use the Enigma implementation

In the enigma repository there are 3 files:

  - *enigma.py*: This is the main file, and when run directly functions as an enigma shell. You can run this as a module.
  - *rotor_gen.py*: This file generates rotor data in JSON format given a rotor map.
  - *rotors.json*: This file is required for *enigma.py* to run, and must be in the same directory as it. It contains all data on each rotor.



## Lorenz / Tunny

### How Lorenz Works

The Lorenz machine essentially works as a Vernam cipher with a pseudo-random key.

The encryption key is generated by two banks of rotors, the 'chi' bank and the 'psi' bank, each with 150 and 290 pins respectively that can be changed from a '1' to a '0', with each bank consitisting of 5 rotors. The key is made by taking the 'active' bit of each rotor in each rotor bank, and taking a bitwise XOR operation on each of these 5-bit keys. This key is then used to encrypt/decrypt a given letter.

The 'chi' bank advances one every time a key is pressed, similar to the enigma rotors, however the 'psi' bank rotates occasionally. This is to do with a third rotor bank, called the 'mu' bank, or motor bank, which consists of 2 rotors, with 37 and 61 pins respectively. The first 'mu' rotor rotates every time a key is pressed, and the second only rotates if the new active bit of the first rotor is a '1'. The 'psi' bank will only advance if the active bit of the second 'mu' rotor is a '1'.

Because of this, decrypting is as easy as encrypting the ciphertext with key that was used to encrypt it initially, similar to the vernam cipher itself.



### How to use the Lorenz implementation

To run this implementation in a shell like manner make sure that "chi_rotors.json", "psi_rotors.json", "mu_rotors.json", "rotor_modules.py", and "main.py" are in the same directory and then run "main.py". This will run it as a shell.

The purpose of each included file is as follows:

chi_rotors 			  -> this encodes every pin, or 'cam', for every chi rotor
psi_rotors 			  -> as above, but for psi
mu_rotors			    -> as above, but for mu
randomise_rotors  -> randomises all cams for every rotor and rewrites each rotor file
letter_lookup		  -> a lookup table for letters to 5 bit binary
rotor_modules		  -> this is a module that contains every rotor class utilised
main 				      -> this is the main file that allows the lorenz to be used in a shell environment



-- ROTOR SETTINGS INPUT --

Rotor settings should be input as such:

To set the chi rotors to [1, 2, 3, 4, 5], mu rotors to [6, 7], and psi rotors to [8, 9, 10, 11, 12], you would enter:

	[1, 2, 3, 4, 5] | [6, 7] | [8, 9, 10, 11, 12] 
